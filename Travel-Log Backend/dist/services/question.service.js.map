{"version":3,"sources":["../../src/services/question.service.ts"],"sourcesContent":["import {CreateQuestionDto} from '@dtos/questions.dto';\nimport { HttpException } from '@exceptions/HttpException';\nimport { Question } from '@interfaces/question.interface';\nimport questionModel from '@models/question.model';\nimport { isEmpty } from '@utils/util';\n\nclass QuestionService {\n  public questions = questionModel;\n\n \n  public async createQuestion(questionData: CreateQuestionDto): Promise<Question> {\n    if (isEmpty(questionData)) throw new HttpException(400, \"blogData is empty\");\n    const data: Question =  await this.questions.create(questionData);\n    console.log(data)\n    return data;\n   \n    \n  }\n    public async findQuestionByBlogId(blogId: String): Promise<Question[]>{\n        if (isEmpty(blogId)) throw new HttpException(400, \"blogId is required\");\n\n        const data:Question[] = await this.questions.find({ blogId: blogId }).sort({createdAt:-1});\n        return data;\n\n    }\n    public async findQuestionByUserId(userId: String): Promise<Question[]>{\n        if (isEmpty(userId)) throw new HttpException(400, \"userId is required\");\n       \n        const data:Question[] = await this.questions.find({ userId: userId }).sort({createdAt:-1});\n      \n        return data;\n\n    }\n   public async findQuestionByblogUser(userId: String): Promise<Question[]>{\n        if (isEmpty(userId)) throw new HttpException(400, \"userId is required\");\n       \n        const data:Question[] = await this.questions.find({ blogUser: userId }).sort({createdAt:-1});\n      \n        return data;\n\n    }\n    public async findQuestionById(id: String): Promise<Question>{\n        if (isEmpty(id)) throw new HttpException(400, \"id is required\");\n\n        const data:Question = await this.questions.findOne({ _id: id });\n        return data;\n\n    }\n     public async addAnswer(id: String,answer:String): Promise<Question>{\n       if (isEmpty(id)) throw new HttpException(400, \"id is required\");\n       else if (isEmpty(answer))throw new HttpException(400, \"answer is required\");\n       else {\n        const data:Question = await this.questions.findOneAndUpdate({ _id: id },{answer:answer});\n        return data; \n       }\n\n        \n\n    }\n public async updateQuestion(questionId:string,question:any ): Promise<Question> {\n   if (isEmpty(questionId)) throw new HttpException(400, \"id is required\");\n   const updateQuestionById = await this.questions.findByIdAndUpdate({ _id: questionId }, {question:question});\n    if (!updateQuestionById) throw new HttpException(409, \"Question doesn't exist\");\n   return updateQuestionById;\n\n    \n   \n      \n  }\n  \n  public async deleteQuestion(questionId: string): Promise<Question> {\n    const deleteQuestionById: Question = await this.questions.findByIdAndDelete(questionId);\n    if (!deleteQuestionById) throw new HttpException(409, \"Question doesn't exist\");\n\n    return deleteQuestionById;\n  }\n}\n\nexport default QuestionService;\n"],"names":["QuestionService","createQuestion","questionData","isEmpty","HttpException","data","questions","create","console","log","findQuestionByBlogId","blogId","find","sort","createdAt","findQuestionByUserId","userId","findQuestionByblogUser","blogUser","findQuestionById","id","findOne","_id","addAnswer","answer","findOneAndUpdate","updateQuestion","questionId","question","updateQuestionById","findByIdAndUpdate","deleteQuestion","deleteQuestionById","findByIdAndDelete","questionModel"],"mappings":";;;;+BA8EA;;aAAA;;+BA7E8B;sDAEJ;sBACF;;;;;;AAExB,IAAA,AAAMA,kBAAN,MAAMA;IAIJ,MAAaC,eAAeC,YAA+B,EAAqB;QAC9E,IAAIC,IAAAA,aAAO,EAACD,eAAe,MAAM,IAAIE,4BAAa,CAAC,KAAK,qBAAqB;QAC7E,MAAMC,OAAkB,MAAM,IAAI,CAACC,SAAS,CAACC,MAAM,CAACL;QACpDM,QAAQC,GAAG,CAACJ;QACZ,OAAOA;IAGT;IACE,MAAaK,qBAAqBC,MAAc,EAAsB;QAClE,IAAIR,IAAAA,aAAO,EAACQ,SAAS,MAAM,IAAIP,4BAAa,CAAC,KAAK,sBAAsB;QAExE,MAAMC,OAAkB,MAAM,IAAI,CAACC,SAAS,CAACM,IAAI,CAAC;YAAED,QAAQA;QAAO,GAAGE,IAAI,CAAC;YAACC,WAAU,CAAC;QAAC;QACxF,OAAOT;IAEX;IACA,MAAaU,qBAAqBC,MAAc,EAAsB;QAClE,IAAIb,IAAAA,aAAO,EAACa,SAAS,MAAM,IAAIZ,4BAAa,CAAC,KAAK,sBAAsB;QAExE,MAAMC,OAAkB,MAAM,IAAI,CAACC,SAAS,CAACM,IAAI,CAAC;YAAEI,QAAQA;QAAO,GAAGH,IAAI,CAAC;YAACC,WAAU,CAAC;QAAC;QAExF,OAAOT;IAEX;IACD,MAAaY,uBAAuBD,MAAc,EAAsB;QACnE,IAAIb,IAAAA,aAAO,EAACa,SAAS,MAAM,IAAIZ,4BAAa,CAAC,KAAK,sBAAsB;QAExE,MAAMC,OAAkB,MAAM,IAAI,CAACC,SAAS,CAACM,IAAI,CAAC;YAAEM,UAAUF;QAAO,GAAGH,IAAI,CAAC;YAACC,WAAU,CAAC;QAAC;QAE1F,OAAOT;IAEX;IACA,MAAac,iBAAiBC,EAAU,EAAoB;QACxD,IAAIjB,IAAAA,aAAO,EAACiB,KAAK,MAAM,IAAIhB,4BAAa,CAAC,KAAK,kBAAkB;QAEhE,MAAMC,OAAgB,MAAM,IAAI,CAACC,SAAS,CAACe,OAAO,CAAC;YAAEC,KAAKF;QAAG;QAC7D,OAAOf;IAEX;IACC,MAAakB,UAAUH,EAAU,EAACI,MAAa,EAAoB;QACjE,IAAIrB,IAAAA,aAAO,EAACiB,KAAK,MAAM,IAAIhB,4BAAa,CAAC,KAAK,kBAAkB;aAC3D,IAAID,IAAAA,aAAO,EAACqB,SAAQ,MAAM,IAAIpB,4BAAa,CAAC,KAAK,sBAAsB;aACvE;YACJ,MAAMC,OAAgB,MAAM,IAAI,CAACC,SAAS,CAACmB,gBAAgB,CAAC;gBAAEH,KAAKF;YAAG,GAAE;gBAACI,QAAOA;YAAM;YACtF,OAAOnB;QACR,CAAC;IAIJ;IACH,MAAaqB,eAAeC,UAAiB,EAACC,QAAY,EAAsB;QAC9E,IAAIzB,IAAAA,aAAO,EAACwB,aAAa,MAAM,IAAIvB,4BAAa,CAAC,KAAK,kBAAkB;QACxE,MAAMyB,qBAAqB,MAAM,IAAI,CAACvB,SAAS,CAACwB,iBAAiB,CAAC;YAAER,KAAKK;QAAW,GAAG;YAACC,UAASA;QAAQ;QACxG,IAAI,CAACC,oBAAoB,MAAM,IAAIzB,4BAAa,CAAC,KAAK,0BAA0B;QACjF,OAAOyB;IAKR;IAEA,MAAaE,eAAeJ,UAAkB,EAAqB;QACjE,MAAMK,qBAA+B,MAAM,IAAI,CAAC1B,SAAS,CAAC2B,iBAAiB,CAACN;QAC5E,IAAI,CAACK,oBAAoB,MAAM,IAAI5B,4BAAa,CAAC,KAAK,0BAA0B;QAEhF,OAAO4B;IACT;;aApEO1B,YAAY4B,sBAAa;;AAqElC;MAEA,WAAelC"}